/*
Q1. What is a Common Table Expression (CTE), and how does it improve SQL query readability? 
   - A CTE is a temporary result set that you can reference within a SELECT, INSERT, UPDATE, or DELETE statement.
   - Improvement: It improves readability by breaking down complex queries into smaller, named logical blocks. Unlike subqueries, CTEs can be named and reused multiple times in the same query, making the logic easier to follow.

Q2. Why are some views updatable while others are read-only? Explain with an example. 
   - Updatable Views: Direct references to underlying table columns without aggregation or complex joins (e.g., SELECT id, name FROM users).
   - Read-Only Views: Contain aggregates (SUM, AVG), DISTINCT, GROUP BY, or UNION. The database cannot determine which specific underlying row to update.
   - Example: A view showing "Average Salary per Department" is read-only because you cannot "update" an average directly; you must update the individual rows that calculate it.

Q3. What advantages do stored procedures offer compared to writing raw SQL queries repeatedly? 
   - Reusability: Write once, call multiple times.
   - Security: Can grant permission to execute the procedure without giving access to underlying tables.
   - Performance: Procedures are often compiled and cached by the database engine, reducing parsing overhead.
   - Maintenance: Logic is centralized in the database; changing it there updates it for all applications.

Q4. What is the purpose of triggers in a database? Mention one use case. 
   - Purpose: To automatically execute a specified set of actions in response to specific events (INSERT, UPDATE, DELETE) on a table.
   - Use Case: Auditing changes (e.g., automatically logging the old value of a row into a history table whenever a record is updated or deleted).

Q5. Explain the need for data modelling and normalization when designing a database. 
   - Data Modeling: Visualizes data relationships to ensure the system meets business requirements before building.
   - Normalization: Organizes data to reduce redundancy (duplicates) and improve integrity. It ensures that when data changes, it only needs to be updated in one place.

 0. SETUP: Create Database and Tables 
CREATE DATABASE IF NOT EXISTS advanced_sql_db;
USE advanced_sql_db;

CREATE TABLE Products (
    ProductID INT PRIMARY KEY,
    ProductName VARCHAR(100),
    Category VARCHAR(50),
    Price DECIMAL(10,2)
);

INSERT INTO Products VALUES
(1, 'Keyboard', 'Electronics', 1200),
(2, 'Mouse', 'Electronics', 800),
(3, 'Chair', 'Furniture', 2500),
(4, 'Desk', 'Furniture', 5500);

CREATE TABLE Sales (
    SaleID INT PRIMARY KEY,
    ProductID INT,
    Quantity INT,
    SaleDate DATE,
    FOREIGN KEY (ProductID) REFERENCES Products (ProductID)
);

INSERT INTO Sales VALUES
(1, 1, 4, '2024-01-05'),
(2, 2, 10, '2024-01-06'),
(3, 3, 2, '2024-01-10'),
(4, 4, 1, '2024-01-11');


-- Q6. Write a CTE to calculate the total revenue for each product 
[cite_start]-- (Revenue = Price * Quantity), and return only products where revenue > 3000. 
WITH ProductRevenue AS (
    SELECT 
        p.ProductName,
        p.Category,
        (p.Price * s.Quantity) AS TotalRevenue
    FROM Products p
    JOIN Sales s ON p.ProductID = s.ProductID
)
SELECT * FROM ProductRevenue
WHERE TotalRevenue > 3000;


-- Q7. [cite_start]Create a view named vw_CategorySummary that shows: Category, TotalProducts, AveragePrice. 
CREATE VIEW vw_CategorySummary AS
SELECT 
    Category, 
    COUNT(ProductID) AS TotalProducts, 
    AVG(Price) AS AveragePrice
FROM Products
GROUP BY Category;

-- Verification Select (Optional)
-- SELECT * FROM vw_CategorySummary;


-- Q8. Create an updatable view containing ProductID, ProductName, and Price. 
-- Then update the price of ProductID = 1 using the view. 
CREATE VIEW vw_ProductDetails AS
SELECT ProductID, ProductName, Price
FROM Products;

UPDATE vw_ProductDetails
SET Price = 1300
WHERE ProductID = 1;


-- Q9. Create a stored procedure that accepts a category name and returns all products 
-- belonging to that category. 
DELIMITER //
CREATE PROCEDURE GetProductsByCategory(IN catName VARCHAR(50))
BEGIN
    SELECT * FROM Products WHERE Category = catName;
END //
DELIMITER ;

-- Test the Procedure (Optional)
-- CALL GetProductsByCategory('Electronics');


-- Q10. Create an AFTER DELETE trigger on the Products table that archives deleted product rows.
-- The archive should store ProductID, ProductName, Category, Price, and DeletedAt timestamp. 

-- First, create the archive table
CREATE TABLE ProductArchive (
    ArchiveID INT AUTO_INCREMENT PRIMARY KEY,
    ProductID INT,
    ProductName VARCHAR(100),
    Category VARCHAR(50),
    Price DECIMAL(10,2),
    DeletedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Next, create the trigger
DELIMITER //
CREATE TRIGGER AfterProductDelete
AFTER DELETE ON Products
FOR EACH ROW
BEGIN
    INSERT INTO ProductArchive (ProductID, ProductName, Category, Price)
    VALUES (OLD.ProductID, OLD.ProductName, OLD.Category, OLD.Price);
END //
DELIMITER ;
